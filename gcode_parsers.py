"""
GCODE parsing utilities and slicer-specific parsers.
"""
import re
from abc import ABC, abstractmethod
from datetime import timedelta
from typing import List, Optional, Dict
from models import ParsedGcode

class IGcodeParser(ABC):
    """Interface for GCODE parsers."""
    
    @abstractmethod
    def can_parse(self, gcode_content: str) -> bool:
        """Check if this parser can handle the given GCODE content."""
        pass
    
    @abstractmethod
    def parse(self, gcode_content: str, filename: str = "") -> ParsedGcode:
        """Parse GCODE content and return structured data."""
        pass

class GcodeParserUtils:
    """Utility functions for GCODE parsing."""
    
    @staticmethod
    def extract_single_float(content: str, marker: str) -> Optional[float]:
        """Extract a single float value following a marker."""
        pattern = rf"{re.escape(marker)}\s*([0-9]*\.?[0-9]+)"
        match = re.search(pattern, content, re.IGNORECASE)
        if match:
            try:
                return float(match.group(1))
            except ValueError:
                return None
        return None
    
    @staticmethod
    def extract_time_from_comment(content: str, patterns: List[str]) -> Optional[timedelta]:
        """Extract print time from comments using multiple patterns."""
        for pattern in patterns:
            match = re.search(pattern, content, re.IGNORECASE | re.MULTILINE)
            if match:
                try:
                    if len(match.groups()) == 3:  # hours, minutes, seconds
                        hours = int(match.group(1) or 0)
                        minutes = int(match.group(2) or 0)
                        seconds = int(match.group(3) or 0)
                        return timedelta(hours=hours, minutes=minutes, seconds=seconds)
                    elif len(match.groups()) == 1:  # total seconds
                        total_seconds = float(match.group(1))
                        return timedelta(seconds=total_seconds)
                except (ValueError, AttributeError):
                    continue
        return None
    
    @staticmethod
    def count_layers(content: str) -> int:
        """Count the number of layers by counting layer change comments."""
        layer_patterns = [
            r";LAYER_CHANGE",
            r";LAYER:",
            r"; layer \d+",
            r"G1 Z\d+\.\d+ F\d+"
        ]
        
        max_count = 0
        for pattern in layer_patterns:
            matches = re.findall(pattern, content, re.IGNORECASE)
            max_count = max(max_count, len(matches))
        
        return max_count
    
    @staticmethod
    def extract_max_z(content: str) -> Optional[float]:
        """Extract maximum Z height from G-code commands."""
        z_moves = re.findall(r"G[01]\s+.*?Z(\d+\.?\d*)", content, re.IGNORECASE)
        if z_moves:
            try:
                return max(float(z) for z in z_moves)
            except ValueError:
                return None
        return None
    
    @staticmethod
    def extract_temperatures(content: str) -> tuple[Optional[float], Optional[float]]:
        """Extract nozzle and bed temperatures."""
        nozzle_temp = GcodeParserUtils.extract_single_float(content, "M104 S") or \
                     GcodeParserUtils.extract_single_float(content, "M109 S")
        bed_temp = GcodeParserUtils.extract_single_float(content, "M140 S") or \
                  GcodeParserUtils.extract_single_float(content, "M190 S")
        return nozzle_temp, bed_temp

class BambuGcodeParser(IGcodeParser):
    """Parser for Bambu Studio generated GCODE files."""
    
    def can_parse(self, gcode_content: str) -> bool:
        """Check for Bambu Studio markers."""
        bambu_markers = [
            "BambuStudio",
            "Bambu Lab",
            "; generated by BambuStudio",
            "filament_used_g"
        ]
        return any(marker in gcode_content for marker in bambu_markers)
    
    def parse(self, gcode_content: str, filename: str = "") -> ParsedGcode:
        """Parse Bambu Studio GCODE."""
        # Extract filament usage
        filament_grams = GcodeParserUtils.extract_single_float(gcode_content, "filament_used_g") or 0.0
        filament_mm = GcodeParserUtils.extract_single_float(gcode_content, "filament_used_mm") or 0.0
        
        # Extract print time
        time_patterns = [
            r"estimated printing time.*?(\d+)h\s*(\d+)m\s*(\d+)s",
            r"time cost.*?(\d+)h\s*(\d+)m\s*(\d+)s",
            r"estimated_printing_time\s*=\s*(\d+)"
        ]
        print_time = GcodeParserUtils.extract_time_from_comment(gcode_content, time_patterns) or timedelta()
        
        # Extract layer info
        layer_count = GcodeParserUtils.count_layers(gcode_content)
        max_z = GcodeParserUtils.extract_max_z(gcode_content) or 0.0
        layer_height = GcodeParserUtils.extract_single_float(gcode_content, "layer_height") or 0.0
        
        # Extract temperatures
        nozzle_temp, bed_temp = GcodeParserUtils.extract_temperatures(gcode_content)
        
        # Extract speeds
        print_speed = GcodeParserUtils.extract_single_float(gcode_content, "outer_wall_speed") or \
                     GcodeParserUtils.extract_single_float(gcode_content, "inner_wall_speed")
        
        return ParsedGcode(
            slicer_name="Bambu Studio",
            file_name=filename,
            estimated_print_time=print_time,
            filament_used_grams=filament_grams,
            filament_used_millimeters=filament_mm,
            max_z_height=max_z,
            layer_count=layer_count,
            nozzle_temperature=nozzle_temp,
            bed_temperature=bed_temp,
            average_print_speed=print_speed,
            extra_metadata={"layer_height": str(layer_height)}
        )

class OrcaGcodeParser(IGcodeParser):
    """Parser for Orca Slicer generated GCODE files."""
    
    def can_parse(self, gcode_content: str) -> bool:
        """Check for Orca Slicer markers."""
        orca_markers = [
            "OrcaSlicer",
            "Orca Slicer",
            "; generated by Orca",
            "total_filament_used_g"
        ]
        return any(marker in gcode_content for marker in orca_markers)
    
    def parse(self, gcode_content: str, filename: str = "") -> ParsedGcode:
        """Parse Orca Slicer GCODE."""
        # Extract filament usage
        filament_grams = GcodeParserUtils.extract_single_float(gcode_content, "total_filament_used_g") or \
                        GcodeParserUtils.extract_single_float(gcode_content, "filament_used_g") or 0.0
        filament_mm = GcodeParserUtils.extract_single_float(gcode_content, "total_filament_used_mm") or \
                     GcodeParserUtils.extract_single_float(gcode_content, "filament_used_mm") or 0.0
        
        # Extract print time
        time_patterns = [
            r"estimated printing time.*?(\d+)h\s*(\d+)m\s*(\d+)s",
            r"printing time.*?(\d+)h\s*(\d+)m\s*(\d+)s",
            r"total_printing_time\s*=\s*(\d+)"
        ]
        print_time = GcodeParserUtils.extract_time_from_comment(gcode_content, time_patterns) or timedelta()
        
        # Extract layer info
        layer_count = GcodeParserUtils.count_layers(gcode_content)
        max_z = GcodeParserUtils.extract_max_z(gcode_content) or 0.0
        layer_height = GcodeParserUtils.extract_single_float(gcode_content, "layer_height") or 0.0
        
        # Extract temperatures
        nozzle_temp, bed_temp = GcodeParserUtils.extract_temperatures(gcode_content)
        
        # Extract speeds
        print_speed = GcodeParserUtils.extract_single_float(gcode_content, "outer_perimeter_speed") or \
                     GcodeParserUtils.extract_single_float(gcode_content, "perimeter_speed")
        
        return ParsedGcode(
            slicer_name="Orca Slicer",
            file_name=filename,
            estimated_print_time=print_time,
            filament_used_grams=filament_grams,
            filament_used_millimeters=filament_mm,
            max_z_height=max_z,
            layer_count=layer_count,
            nozzle_temperature=nozzle_temp,
            bed_temperature=bed_temp,
            average_print_speed=print_speed,
            extra_metadata={"layer_height": str(layer_height)}
        )

class CrealityGcodeParser(IGcodeParser):
    """Parser for Creality Slicer generated GCODE files."""
    
    def can_parse(self, gcode_content: str) -> bool:
        """Check for Creality Slicer markers."""
        creality_markers = [
            "Creality",
            "CrealityPrint",
            "; generated by Creality",
            "Ender",
            "CR-"
        ]
        return any(marker in gcode_content for marker in creality_markers)
    
    def parse(self, gcode_content: str, filename: str = "") -> ParsedGcode:
        """Parse Creality Slicer GCODE."""
        # Extract filament usage (often in comments)
        filament_patterns = [
            r"filament used.*?(\d+\.?\d*)g",
            r"material used.*?(\d+\.?\d*)g",
            r"Material:.*?(\d+\.?\d*)g"
        ]
        filament_grams = 0.0
        for pattern in filament_patterns:
            match = re.search(pattern, gcode_content, re.IGNORECASE)
            if match:
                try:
                    filament_grams = float(match.group(1))
                    break
                except ValueError:
                    continue
        
        # Calculate filament length from extrusion commands if weight not found
        filament_mm = 0.0
        if filament_grams == 0.0:
            e_values = re.findall(r"E(\d+\.?\d*)", gcode_content)
            if e_values:
                try:
                    filament_mm = max(float(e) for e in e_values)
                    # Rough conversion assuming 1.75mm filament density
                    filament_grams = filament_mm * 0.0029  # approximation
                except ValueError:
                    pass
        
        # Extract print time
        time_patterns = [
            r"estimated printing time.*?(\d+)h\s*(\d+)m\s*(\d+)s",
            r"Print time:.*?(\d+)h\s*(\d+)m\s*(\d+)s",
            r"TIME:(\d+)"
        ]
        print_time = GcodeParserUtils.extract_time_from_comment(gcode_content, time_patterns) or timedelta()
        
        # Extract layer info
        layer_count = GcodeParserUtils.count_layers(gcode_content)
        max_z = GcodeParserUtils.extract_max_z(gcode_content) or 0.0
        
        # Extract temperatures
        nozzle_temp, bed_temp = GcodeParserUtils.extract_temperatures(gcode_content)
        
        # Extract speeds from G-code commands
        speed_matches = re.findall(r"F(\d+)", gcode_content)
        print_speed = None
        if speed_matches:
            try:
                # Convert from mm/min to mm/s
                speeds = [float(s) / 60 for s in speed_matches if float(s) < 20000]
                print_speed = sum(speeds) / len(speeds) if speeds else None
            except ValueError:
                pass
        
        return ParsedGcode(
            slicer_name="Creality Slicer",
            file_name=filename,
            estimated_print_time=print_time,
            filament_used_grams=filament_grams,
            filament_used_millimeters=filament_mm,
            max_z_height=max_z,
            layer_count=layer_count,
            nozzle_temperature=nozzle_temp,
            bed_temperature=bed_temp,
            average_print_speed=print_speed
        )

class GenericGcodeParser(IGcodeParser):
    """Generic parser for unknown GCODE formats."""
    
    def can_parse(self, gcode_content: str) -> bool:
        """Always returns True as fallback parser."""
        return True
    
    def parse(self, gcode_content: str, filename: str = "") -> ParsedGcode:
        """Parse GCODE using generic extraction methods."""
        # Try to extract basic info using generic patterns
        layer_count = GcodeParserUtils.count_layers(gcode_content)
        max_z = GcodeParserUtils.extract_max_z(gcode_content) or 0.0
        nozzle_temp, bed_temp = GcodeParserUtils.extract_temperatures(gcode_content)
        
        # Generic time patterns
        time_patterns = [
            r"time.*?(\d+)h\s*(\d+)m\s*(\d+)s",
            r"duration.*?(\d+)h\s*(\d+)m\s*(\d+)s",
            r"(\d+)\s*seconds?"
        ]
        print_time = GcodeParserUtils.extract_time_from_comment(gcode_content, time_patterns) or timedelta()
        
        # Calculate filament usage from extrusion
        e_values = re.findall(r"E(\d+\.?\d*)", gcode_content)
        filament_mm = 0.0
        if e_values:
            try:
                filament_mm = max(float(e) for e in e_values)
            except ValueError:
                pass
        
        # Rough conversion to grams (assuming PLA 1.75mm)
        filament_grams = filament_mm * 0.0029 if filament_mm > 0 else 0.0
        
        return ParsedGcode(
            slicer_name="Unknown Slicer",
            file_name=filename,
            estimated_print_time=print_time,
            filament_used_grams=filament_grams,
            filament_used_millimeters=filament_mm,
            max_z_height=max_z,
            layer_count=layer_count,
            nozzle_temperature=nozzle_temp,
            bed_temperature=bed_temp
        )

class GcodeParserFactory:
    """Factory for selecting appropriate GCODE parser."""
    
    def __init__(self):
        self.parsers = [
            BambuGcodeParser(),
            OrcaGcodeParser(),
            CrealityGcodeParser(),
            GenericGcodeParser()  # Always last as fallback
        ]
    
    def get_parser(self, gcode_content: str) -> IGcodeParser:
        """Get the appropriate parser for the given GCODE content."""
        for parser in self.parsers:
            if parser.can_parse(gcode_content):
                return parser
        
        # This should never happen due to GenericGcodeParser fallback
        raise ValueError("No suitable parser found for GCODE content")
    
    def parse_gcode(self, gcode_content: str, filename: str = "") -> ParsedGcode:
        """Parse GCODE content using the appropriate parser."""
        parser = self.get_parser(gcode_content)
        return parser.parse(gcode_content, filename)
